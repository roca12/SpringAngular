{"ast":null,"code":"/**\n * @license\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://raw.githubusercontent.com/l-lin/angular-datatables/master/LICENSE\n */\nimport { Directive, ElementRef, Input, Renderer2, ViewContainerRef } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport * as ɵngcc0 from '@angular/core';\n\nvar DataTableDirective =\n/** @class */\nfunction () {\n  function DataTableDirective(el, vcr, renderer) {\n    this.el = el;\n    this.vcr = vcr;\n    this.renderer = renderer;\n    /**\n     * The DataTable option you pass to configure your table.\n     */\n\n    this.dtOptions = {};\n  }\n\n  DataTableDirective.prototype.ngOnInit = function () {\n    var _this = this;\n\n    if (this.dtTrigger) {\n      this.dtTrigger.subscribe(function (options) {\n        _this.displayTable(options);\n      });\n    } else {\n      this.displayTable(null);\n    }\n  };\n\n  DataTableDirective.prototype.ngOnDestroy = function () {\n    if (this.dtTrigger) {\n      this.dtTrigger.unsubscribe();\n    }\n\n    if (this.dt) {\n      this.dt.destroy(true);\n    }\n  };\n\n  DataTableDirective.prototype.displayTable = function (dtOptions) {\n    var _this = this; // assign new options if provided\n\n\n    if (dtOptions) {\n      this.dtOptions = dtOptions;\n    }\n\n    this.dtInstance = new Promise(function (resolve, reject) {\n      Promise.resolve(_this.dtOptions).then(function (resolvedDTOptions) {\n        // validate object\n        var isTableEmpty = Object.keys(resolvedDTOptions).length === 0 && $('tbody tr', _this.el.nativeElement).length === 0;\n\n        if (isTableEmpty) {\n          reject('Both the table and dtOptions cannot be empty');\n          return;\n        } // Using setTimeout as a \"hack\" to be \"part\" of NgZone\n\n\n        setTimeout(function () {\n          // Assign DT properties here\n          var options = {\n            rowCallback: function rowCallback(row, data, index) {\n              if (resolvedDTOptions.columns) {\n                var columns = resolvedDTOptions.columns;\n\n                _this.applyNgPipeTransform(row, columns);\n\n                _this.applyNgRefTemplate(row, columns, data);\n              } // run user specified row callback if provided.\n\n\n              if (resolvedDTOptions.rowCallback) {\n                resolvedDTOptions.rowCallback(row, data, index);\n              }\n            }\n          }; // merge user's config with ours\n\n          options = Object.assign({}, resolvedDTOptions, options);\n          _this.dt = $(_this.el.nativeElement).DataTable(options);\n          resolve(_this.dt);\n        });\n      });\n    });\n  };\n\n  DataTableDirective.prototype.applyNgPipeTransform = function (row, columns) {\n    // Filter columns with pipe declared\n    var colsWithPipe = columns.filter(function (x) {\n      return x.ngPipeInstance && !x.ngTemplateRef;\n    });\n    colsWithPipe.forEach(function (el) {\n      var pipe = el.ngPipeInstance; // find index of column using `data` attr\n\n      var i = columns.findIndex(function (e) {\n        return e.data === el.data;\n      }); // get <td> element which holds data using index\n\n      var rowFromCol = row.childNodes.item(i); // Transform data with Pipe\n\n      var rowVal = $(rowFromCol).text();\n      var rowValAfter = pipe.transform(rowVal); // Apply transformed string to <td>\n\n      $(rowFromCol).text(rowValAfter);\n    });\n  };\n\n  DataTableDirective.prototype.applyNgRefTemplate = function (row, columns, data) {\n    var _this = this; // Filter columns using `ngTemplateRef`\n\n\n    var colsWithTemplate = columns.filter(function (x) {\n      return x.ngTemplateRef && !x.ngPipeInstance;\n    });\n    colsWithTemplate.forEach(function (el) {\n      var _a = el.ngTemplateRef,\n          ref = _a.ref,\n          context = _a.context; // get <td> element which holds data using index\n\n      var i = columns.findIndex(function (e) {\n        return e.data === el.data;\n      });\n      var cellFromIndex = row.childNodes.item(i); // reset cell before applying transform\n\n      $(cellFromIndex).html(''); // render onto DOM\n      // finalize context to be sent to user\n\n      var _context = Object.assign({}, context, context === null || context === void 0 ? void 0 : context.userData, {\n        adtData: data\n      });\n\n      var instance = _this.vcr.createEmbeddedView(ref, _context);\n\n      _this.renderer.appendChild(cellFromIndex, instance.rootNodes[0]);\n    });\n  };\n\n  DataTableDirective.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: ViewContainerRef\n    }, {\n      type: Renderer2\n    }];\n  };\n\n  DataTableDirective.propDecorators = {\n    dtOptions: [{\n      type: Input\n    }],\n    dtTrigger: [{\n      type: Input\n    }]\n  };\n\n  DataTableDirective.ɵfac = function DataTableDirective_Factory(t) {\n    return new (t || DataTableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  DataTableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DataTableDirective,\n    selectors: [[\"\", \"datatable\", \"\"]],\n    inputs: {\n      dtOptions: \"dtOptions\",\n      dtTrigger: \"dtTrigger\"\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return DataTableDirective;\n}();\n\nexport { DataTableDirective }; //# sourceMappingURL=angular-datatables.directive.js.map","map":null,"metadata":{},"sourceType":"module"}